{
package pparser
}

program = rule:rule {
    return &ast.Program{
        []*ast.Rule{
            rule.(*ast.Rule),
        },
    }, nil
}

rule = rule:(block_rule / no_block_rule) {
    return rule, nil
}

block_rule = _ expression:boolean_expression _ '{' _ "print" _ '(' _ "%0" _ ')' _ '}' _EOL {
    return &ast.Rule{
        Selection: expression.(ast.Expression),
        Block:     &ast.Block{
		    []*ast.Command{ast.NewPrintCommand([]ast.Expression{ast.NewVariableExpression("%0")})},
	    },
    }, nil
}

no_block_rule = _ expression:boolean_expression _EOL {
    return &ast.Rule{
        Selection: expression.(ast.Expression),
        Block:     ast.NewPrintlnBlock(),
    }, nil
}

boolean_expression = _ lhs:term _ comparison:comparison _ rhs:term {
    return &ast.Comparison{
        Left:     lhs.(ast.Value),
        Operator: comparison.(ast.Operator),
        Right:    rhs.(ast.Value),
    }, nil
}

term = identifier:(column_identifier / date / decimal / integer / regular_expression) { return identifier, nil }

column_identifier = '%' [0-9]+ { return ast.NewVarValue(string(c.text)), nil }

regular_expression = ('/' [^/]* '/' / '|' [^|]* '|') {
    s := string(c.text)
	return ast.NewRegexpValue(s[1:len(s)-1])
}

date        = [0-9][0-9][0-9][0-9] '-' [0-9][0-9] '-' [0-9][0-9] 'T' {
    return ast.NewDateTimeValue(string(c.text))
}

decimal     = [0-9]+ '.' [0-9]* { return ast.NewDoubleFromString(string(c.text)) }

integer     = integer:(binary_int / hex_int / decimal_int) { return integer, nil }
binary_int  = "0b" [0-1_]+    { return ast.NewIntegerValueFromBinaryString(string(c.text)) }
hex_int     = "0x" [0-9A-F_]+ { return ast.NewIntegerValueFromHexString(string(c.text)) }
decimal_int = [0-9_]+         { return ast.NewIntegerValue(string(c.text)) }

comparison = comparison:(le / lt / eq / ne / ge / gt) { return comparison, nil }
lt = '<'  { return ast.LT_Operator, nil }
le = "<=" { return ast.LE_Operator, nil }
eq = "==" { return ast.EQ_Operator, nil }
ne = "!=" { return ast.NE_Operator, nil }
ge = ">=" { return ast.GE_Operator, nil }
gt = '>'  { return ast.GT_Operator, nil }

// The whitespace rule is used to capture whitespace. Most grammars that I
// build are not whitespace sensitive, so the results of matching this will
// normally be discarded somehow.
_ "whitespace" <- [ \n\t\r]*

// Using the whitespace rule before an EOL means the _ rule will consume the
// EOL characters, and the EOL won't be available to match.
_EOL "whitespaceEOL" = [ \t]* EOL

// Windows             - Lines end with both a <CR> (\r) followed by a <LF> (/n) character
// Linux               - Lines end with only a <LF> (\n) character
// Macintosh (Mac OSX) - Lines end with only a <LF> (\n) character
// Macintosh (old)     - Lines end with only a <CR> (\r) character
// The line might be the last line in the file, so EOF is a valid EOL too.
EOL = [\n\r] / "\r\n" / EOF

// An EOF character is anything that is not a character.
EOF = !.
